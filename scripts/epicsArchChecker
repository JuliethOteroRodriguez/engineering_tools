#!/reg/g/pcds/pyps/conda/py36/envs/pcds-4.1.6/bin/python

"""
epicsArch Checker
This script helps the engineers and scientists to verify
if the epicsArch files have errors by creating 3 types
of report:
1. Pvs and Aliases duplicated.
2. Pvs with no alias and Aliases with no pvs.
3. Pvs no connected.
"""
import os
import argparse
import ophyd.signal
from prettytable import PrettyTable


def main():
    a_file = open("/tmp/output.txt", "w")
    a_file.truncate()
    a_file.close()
    parser = argparse.ArgumentParser(description='It creates a report with:'
                                     ' Pvs and Aliases duplicated.'
                                     ' Pvs with no alias and aliases'
                                     ' with no Pv.'
                                     ' Pvs no connected.'
                                     ' Usage: epicsArchChecker'
                                     ' <Fullpath-name-file>. ')
    parser.add_argument('pathname',
                        help='Full pathname of the file to check'
                        ' e.g /xpp/misc/epicsArch3.txt',
                        type=str)
    args = parser.parse_args()

    fullpath = args.pathname
    dirpath = os.path.dirname(fullpath)
    filename = os.path.basename(fullpath)
    os.chdir(dirpath)
    filenamesList = filenames(filename)
    info = readFiles(filenamesList, filename)
    myKeys, myPvs, myFiles, warnings = createLists(info)
    dmyKeys, dmyPvs, myKeys, myPvs, myFiles = checkDuplicates(
        myKeys, myPvs, myFiles
    )
    indKeys, indPvs, myKeys, myPvs, myFiles = findIndex(
        dmyKeys, dmyPvs, myKeys, myPvs, myFiles
    )
    reportDuplicates(indKeys, indPvs, myKeys, myPvs, myFiles)
    reportWarnings(warnings)
    ReportStatusPv(myKeys, myPvs, myFiles)


def filenames(filename):
    """
    This function will interate throught all the files inside of the main file,
    recolecting those file names and storing them into a list.
    """
    filenamesList = []
    with open(filename, 'r') as f:
        for line in f:
            if line[0] == "<":
                readfilename = line[2:].strip()
                filenamesList.append(readfilename)
                filenamesList += filenames(readfilename)
    return(filenamesList)


def readFiles(filenamesList, filename):
    """
    This function will use the filenamesList to open the files an collect the a
    list per file with the name of the file, the aliases, and the pvs.
    """
    filenamesList.append(filename)
    info = []
    for i in filenamesList:
        myinfo = [filename]
        with open(i, 'r') as f:
            myinfo.append(i)
            for line in f:
                if (line[0] != "<") and (line[0] == "*"):
                    myinfo.append(line.strip())
                elif (line[0].isalpha() or line[0].isnumeric()):
                    myinfo.append(line.strip())
            info.append(myinfo)
    return(info)


def createLists(info):
    """
    This fucntion will separate the information collected per file
    and it will separte the alliases, pvs and filename, by storing
    them in three different lists. It will also store in a list the
    Pvs with no alias and the Aliases with no PV.
    """
    myKeys = []
    myPvs = []
    myFiles = []
    warnings = []
    for i in range(len(info)):
        if len(info[i]) > 2:
            for index, elem in enumerate(info[i]):
                warning = []
                if (index < len(info[i]) and index - 2 >= 0):
                    if elem == info[i][-1]:
                        if "*" in elem:
                            warning.append(elem)
                            warning.append('No Pv!')
                            warning.append(info[i][1])
                        else:
                            if "*" not in info[i][index - 1]:
                                warning.append('No Alias!')
                                warning.append(elem)
                                warning.append(info[i][1])
                            else:
                                myPvs.append(elem)
                    if elem != info[i][-1]:
                        if "*" in elem and "*" in info[i][index - 1]:
                            if "*" in info[i][index + 1]:
                                warning.append(elem)
                                warning.append('No Pv!')
                                warning.append(info[i][1])
                            else:
                                myKeys.append(elem)
                                myFiles.append(info[i][1])
                        elif "*" in elem and "*" not in info[i][index - 1]:
                            if "*" in info[i][index + 1]:
                                warning.append(elem)
                                warning.append('No Pv!')
                                warning.append(info[i][1])
                            else:
                                myKeys.append(elem)
                                myFiles.append(info[i][1])
                        elif "*" not in elem:
                            if "*" not in info[i][index - 1]:
                                warning.append('No Alias!')
                                warning.append(elem)
                                warning.append(info[i][1])
                            else:
                                myPvs.append(elem)
                if warning:
                    warnings.append(warning)
    return(myKeys, myPvs, myFiles, warnings)


def checkDuplicates(myKeys, myPvs, myFiles):
    """
    This fucntion will check the duplicated elements inside of
    the lists myKeys, and myPvs.
    """
    sKeys = sorted(myKeys)
    dmyKeys = []
    for i in sKeys:
        if sKeys.count(i) > 1:
            if i not in dmyKeys:
                dmyKeys.append(i)
    sPvs = sorted(myPvs)
    dmyPvs = []
    for i in sPvs:
        if sPvs.count(i) > 1:
            if i not in dmyPvs:
                dmyPvs.append(i)
    return(dmyKeys, dmyPvs, myKeys, myPvs, myFiles)


def findIndex(dmyKeys, dmyPvs, myKeys, myPvs, myFiles):
    """
    This fucntion will find the index of each duplicated
    element inside of the lists myKeys, and myPvs.
    """
    indKeys = []
    indPvs = []
    for i in range(len(dmyKeys)):
        for j in range(len(myKeys)):
            if dmyKeys[i] == myKeys[j]:
                indKeys.append(j)
    for i in range(len(dmyPvs)):
        for j in range(len(myPvs)):
            if dmyPvs[i] == myPvs[j]:
                indPvs.append(j)
    return(indKeys, indPvs, myKeys, myPvs, myFiles)


def reportDuplicates(indKeys, indPvs, myKeys, myPvs, myFiles):
    """This fucntion will display the duplicate Pvs and/or  Aliases."""
    duplikey = []
    duplipvs = []
    for j in indKeys:
        duplikey.append(myKeys[j])
    for j in indPvs:
        duplipvs.append(myPvs[j])

    c_key = sorted(set(duplikey))
    c_pv = sorted(set(duplipvs))

    if c_key and c_pv:
        print("Report of duplicate Aliases and Pvs from the input file: \n")
    elif c_pv:
        print("Report of duplicate Pvs from the input file: \n")
    elif c_key:
        print("Report of duplicate Aliases from the input file: \n")
    size_per_col = 40
    nameA = "Alias"
    nameL = "Location"
    nameP = "Pv"
    ms0 = "**Alias assigned to a pv with other alias**"
    ms1 = "**Alias name has an space**"
    if c_key:
        print("\n------------------------------------",
              "Duplicate by Aliases"
              "------------------------------------\n")
        for i in c_key:
            if " " in i:
                print("Duplicate Alias: ", i,
                      " ***Aliases should not have spaces***")
            else:
                print("Duplicate Alias: ", i)
            print("\n")
            print(str(nameP).center(size_per_col),
                  str(nameL).center(size_per_col))
            print(90*"=")
            for j in range(len(myKeys)):
                if i == myKeys[j]:
                    if i == myPvs[j]:
                        print(str(myPvs[j]).center(size_per_col),
                              str(myFiles[j]).center(size_per_col),
                              (ms0).center(size_per_col))
                    else:
                        print(str(myPvs[j]).center(size_per_col),
                              str(myFiles[j]).center(size_per_col))
            print(90*"=")
            print("\n")
    if c_pv:
        print("------------------------------------",
              "Duplicate by Pvs",
              "------------------------------------\n")
        for i in c_pv:
            print("Duplicate Pv: ", i)
            print("\n")
            print(str(nameA).center(size_per_col),
                  str(nameL).center(size_per_col))
            print(90*"=")
            for j in range(len(myPvs)):
                if i == myPvs[j]:
                    if " " in myKeys[j]:
                        print(str(myKeys[j]).center(size_per_col),
                              str(myFiles[j]).center(size_per_col),
                              (ms1).center(size_per_col))
                    else:
                        print(str(myKeys[j]).center(size_per_col),
                              str(myFiles[j]).center(size_per_col))
            print(90*"=")
            print("\n")


def reportWarnings(warnings):
    """
    This fucntion will display the Pvs with no alias
    and/or Aliases with no pv.
    """
    print("Pvs with no alias and Aliases with no pv, WARNING!!!!:")
    sorted_list = sorted(warnings, key=lambda x: x[1])
    table = PrettyTable()
    table.field_names = ["Alias", "Pv name", "Location"]
    table.add_rows(sorted_list)
    print(table)



def ReportStatusPv(myKeys, myPvs, myFiles):
    """This fucntion will display the no connected Pvs."""
    totalInfo = []
    for i in range(len(myPvs)):
        statusPv = []
        try:
            ophyd.signal.EpicsSignal(myPvs[i]).get()
        except Exception:
            statusPv.append(myPvs[i])
            statusPv.append("No connected!")
            statusPv.append(myKeys[i])
            statusPv.append(myFiles[i])
        if statusPv:
            totalInfo.append(statusPv)
    print("Pvs NO connected:")
    sorted_list = sorted(totalInfo, key=lambda x: x[3])
    table = PrettyTable()
    table.field_names = ["Pv Name", "Status", "Alias", "Location"]
    table.add_rows(sorted_list)
    print(table)


if __name__ == "__main__":
    main()
